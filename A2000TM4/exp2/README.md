# 实验2

- 课程文档：[README.md](../../README.md)

## 任务2-1

- 建立一个全局变量`mode`，用来记录当前模式. 事实上，本任务已使用了最简单的FSM：状态转移条件相同，状态转移动作为空.

## 任务2-2

- 本任务用FSM实现. 建立一个静态全局变量`cur_state`，记录当前状态号；全局变量`pre_state`记录上一状态号. FSM规则设计如下：
  - **状态定义**. 0-计时进行；1-计时暂停；2-计时清零.
  - **状态转移条件**：(C01, C10) 当状态0/1时，按一次1号键，转移至状态1/0；(C02, C12) 当状态0/1时，按一次2号键，转移至状态2；(C2*) 当状态2时，完成一次状态动作后，返回至上一状态.
  - **状态转移动作**：(C02, C12) 保存当前状态号（通过更新 `pre_state`），将计数值清零；(C01, C10) 保存当前状态号（通过更新 `pre_state`）.
  - **状态动作**：0-计时进行，最左端LED灯亮，其余全灭；1-计时暂停，LED灯全灭；2-*立即刷新数码管的值*（以保证清零能立即可见），然后返回上一状态号(`pre_state`).
  - 状态转移、状态动作全在主程序循环中实现. 这样做的考虑是：尽量精简 systick 异常的 ISR `void SysTick_Handler(void)`，保证其在一个中断周期（已设定为 20ms）内执行完毕.
    - 也可在 systick 的 ISR `void SysTick_Handler(void)` 中实现，见实验3的例程 [`exp3_0.c`](../exp3/exp3_0.c)，或课程视频 [工程实践与科技创新II-A_2.2定时扫描法检测按键 (sjtu.edu.cn)](https://vshare.sjtu.edu.cn/play/cbc1b104598c0259b9a4de6087421c08)

## 任务2-3

- 若一个`uint8_t`类型的变量发生下溢，可能会引起一种异常，导致主程序不能正常执行. 故应或修改相应的 ISR，或避免发生下溢. 相信这是课程组设置本任务的用意之一. *__建议用调试工具验证__*.
- 计时初值为 9999，故清零动作应将数码管置为 9999.

## 任务2-4

- 增加全局变量 `flag_DecCnt` 表示计数方向.
- 按照调用关系，逐级上查 [`TM1638_RefreshDIGIandLED()`](`tm1638.c`)、[`TM1638_DigiSegment()`](`tm1638.c`) 的源代码和注释可知 TM1638 芯片相关 API 函数的用法，得知可向全局变量 `digit[8]` 里存 `'_'`,`'A'`,`'U'` 等字符.
