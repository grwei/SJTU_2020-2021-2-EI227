# 实验2

## 任务2-1

- 建立一个全局变量`mode`，用来记录当前模式. 事实上，本任务已使用了最简单的FSM：状态转移条件相同，状态转移动作为空.

## 任务2-2

- 本任务用FSM实现. 建立一个全局变量`cur_state`，记录当前状态号；全局变量`pre_state`记录上一状态号. FSM规则设计如下：
  - **状态定义**. 0-计时进行；1-计时暂停；2-计时清零.
  - **状态转移条件**：(C01, C10) 当状态0/1时，按一次1号键，转移至状态1/0；(C02, C12) 当状态0/1时，按一次2号键，转移至状态2；(C2*) 当状态2时，完成一次状态动作后，返回至上一状态.
  - **状态转移动作**：(C02, C12) 保存当前状态号（通过更新 pre_state），将计数值清零；(C01, C10) 保存当前状态号（通过更新 pre_state）.
  - **状态动作**：0-计时进行，最左端LED灯亮，其余全灭；1-计时暂停，LED灯全灭；2-*立即刷新数码管的值*（以保证清零能立即可见），然后返回上一状态号(pre_state).
  - 状态转移、状态动作全在主程序循环中实现. 这样做的考虑是：尽量精简systick异常的ISR，保证其在一个中断周期（已设定为50ms）内执行完毕.

## 任务2-3

- 若一个`uint8_t`类型的变量发生下溢，可能会引起一种异常，导致主程序不能正常执行. 故应或修改相应的ISR，或避免发生下溢. 相信这是课程组设置本任务的用意之一. *__建议用调试工具验证__*.
- 计时初值为9999，故清零动作应将数码管值为9999.

## 任务2-4

- 按照调用关系，逐级上查 [`TM1638_RefreshDIGIandLED()`](tm1638.c) -> [`TM1638_DigiSegment()`](tm1638.c) 的源代码和注释可知TM1638芯片相关API函数的用法.
